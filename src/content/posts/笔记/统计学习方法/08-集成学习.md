---

title: 08-集成学习
published: 2024-03-19
description: ''
image: ''
tags: []
category: '统计学习方法'
draft: false 
lang: ''

---

<!-- ![](./assets/images/533eaf5ac9f1a4fec7290a324f9be5c.png) -->

## 1.1 什么是集成学习

![](./assets/images/2025-04-02-21-37-02-9cdff22c5956451d37d7cc569a08bcf.png)

集成学习通过建立几个模型来解决单一预测问题。它的工作原理是生成多个分类器/模型，各自独立地学习和作出预测。这些预测最后结合成组合预测，因此优于任何一个单分类的做出预测。

## 1.2 集成学习中boosting和Bagging

![](./assets/images/2025-04-02-21-37-35-dfd2e08b605f04e712f0fcf7876dbfe.png)

## 2.1 Bagging集成原理

![](./assets/images/2025-04-02-21-37-47-91a072b7f74f67610039ef586d2ddc5.png)

![](./assets/images/2025-04-02-21-39-10-c523c3a742cbacb483bd63c1488e346.png)

![](./assets/images/2025-04-02-21-39-17-5c33288628a86db13543408f4d949b5.png)

![](./assets/images/2025-04-02-21-39-24-6ba307840e219c0ef48206e39f68fdd.png)

![](./assets/images/2025-04-02-21-39-31-60e23ec002b2fde1e3c27dfa2b68718.png)

## 2.2 随机森林构造过程

![](./assets/images/2025-04-02-21-39-42-9beb11930af1e437c80531be0672a09.png)

![](./assets/images/2025-04-02-21-39-47-c9799440a6e99d1c0eebf19fbf31651.png)

## 3.1 包外估计(Out-of-Bag Estimate)

在随机森林的构造中，如果进行有放回的抽样，总会有一部分样本是选不到的，称之为包外数据，当数据足够多，对于任意一组数据是包外数据的概率是：

![](./assets/images/2025-04-02-21-40-06-01c58b51b17375a069e80ae13cf417d.png)

由于基分类器是构建在训练样本的⾃助抽样集上的，只有约 63.2％ 原样本集出现在中，⽽剩余的 36.8％ 的数据作为包
外数据，可以⽤于基分类器的验证集。

经验证，包外估计是对集成分类器泛化误差的无偏估计. 在随机森林算法中数据集属性的重要性、分类器集强度和分类器间相关性计算都依赖于袋外数据。

## 3.2 包外估计的用途

- 当基学习器是决策树时，可使⽤包外样本来辅助剪枝
   ，或用于估计决策树中各结点的后验概率以辅助对零训练样本结点的处理；
- 当基学习器是神经网络时，可使用包外样本来辅助早期停止以减小过拟合 。

## 4.1 Boosting

随着学习的积累从弱到强

简而言之：每新加入一个弱学习器，整体能力就会得到提升

![](./assets/images/2025-04-02-21-40-23-0c81b372d8cedaa21ef9fab91d07fad.png)

每轮训练，调整数据分布，将训练注意力集中在错误数据，即对正确的数据进行缩小，错误的进行放大。

## 4.2 bagging与boosting的区别

![](./assets/images/2025-04-02-21-40-51-9decf85bc5baed79dfe3da3a6dc132d.png)

## 5.1 AdaBoost构造过程

![](./assets/images/2025-04-02-21-41-24-f701878bd60415f7b927992d553d526.png)

![](./assets/images/2025-04-02-21-41-31-f2c8a9ad065eda231406fe283669775.png)

![](./assets/images/2025-04-02-21-41-40-1aa23cf850732639beace005de85e7c.png)

## 6.1 GBDT

梯度提升决策树(Gradient Boosting Decision Tree)

GBDT = 梯度提升 +
Boosting + 决策树

6.1.1 回归树生成算法

![](./assets/images/2025-04-02-21-41-45-6a9daad1b744071b7e4f87b739aee65.png)

6.1.2 提升树算法

![](./assets/images/2025-04-02-21-42-13-1606f26b9919f43ed102702bf081d85.png)

![](./assets/images/2025-04-02-21-42-24-6076c0d7eb748ce03a6909f635e9ea4.png)

![](./assets/images/2025-04-02-21-42-33-58482768fd5598890aa26fddb0181ef.png)

当损失函数是平方损失和指数损失函数时，梯度提升树每一步优化时很简单的，但对于一般损失函数而言，往往每一步优化起来不那么容易，因此使用GBDT，利用最速下降的近似方法，关键是利用损失函数的负梯度作为提升树算法中的残差近似值

![](./assets/images/2025-04-02-21-42-47-7610d4382404d934b3af1b84f8fa659.png)

![](./assets/images/2025-04-02-21-42-57-1ebd8c666363f729d96f72ad5562578.png)

## 7.1 XGBoost

![](./assets/images/2025-04-02-21-43-18-e4776594a6019817c618765b1e9e224.png)

![](./assets/images/2025-04-02-21-43-23-bd18eb7fc352c1b27ddb6fb0eeb461a.png)